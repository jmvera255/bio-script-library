#! /usr/bin/perl

use strict;
use Getopt::Std;

my (%opts);
getopts("RpmS:B", \%opts);

my $USAGE = "\nUsage: perl ntcov2bedgraph.pl <options> <ntcov.txt> > STDOUT

This script will convert a ntcov.txt file (bedTools genomeCoverageBed -d) to a bed file or
a bedgraph file, the latter being for visualization purposes. This is useful is you are making modifications
to the values of read coverage in the ntcov.txt file (e.g. normalization, pooling, averaging, etc) but then want 
to visualize these modified coverage values.

Where options are:
	-B	output a BED file where each position in the ntcov.txt file becomes
		a bed feature; ignores positions with coverage = 0

    for bed or bedgraph output:
	-p	specifies that this file is for the plus strand of DNA
	-m	specifies that this file is for the minus strand of the DNA

    for ntcov output:
	-R	reverse conversion, i.e. bedgraph to ntcov.txt
	-S      <genome.txt> must provide a genome dictionary (seqstat.pl can make this for you!)

This script was written by Jessica M. Vera, for questions please contact her.\n\n";

if(@ARGV != 1){
	die "\nNo input file provided\n$USAGE";
}
if((not defined $opts{p}) && (not defined $opts{m})){
	if(not defined $opts{R}){
		die "\nUser must specify a strand!\n$USAGE";
	}
}
if(defined $opts{R} && not defined $opts{S}){
	die "User must specify a genome dictionary/seqstat file when performing reverse conversion!\n$USAGE";
}

my $file = shift; ## corrected ntcov.txt for one strand
#my $file2 = shift; ## corrected ntcov.txt for the other strand
## nt cov files generated by genomeCoverageBed -d

if(not defined $opts{R}){
	my (%coverage, %consolidate, $strand, $color);
	open (FILE, "< $file") || die "cannot open file $file\n";
	while (my $line1 = <FILE>){
		chomp ($line1);
		my @tabs = split("\t", $line1);
		my $chr = $tabs[0];
		my $pos = $tabs[1];
		my $cov = $tabs[2];
		if(defined $opts{m}){
			$cov = $cov * -1;
			$coverage{$chr}{$pos} = $cov;
		}
		elsif(defined $opts{p}){
			$coverage{$chr}{$pos} = $cov;
		}
	}
	close (FILE1);
	
	foreach my $key1 (sort {$a cmp $b} keys %coverage){
		my @sorted_coords = sort{ $a <=> $b } keys %{$coverage{$key1}};
		my $last = pop(@sorted_coords);
		my $last_cov = $coverage{$key1}{$last};
		my $first_cov = $coverage{$key1}{$sorted_coords[0]};
		$consolidate{$key1}{$last} = $last_cov;
		$consolidate{$key1}{$sorted_coords[0]} = $first_cov;
	#	print "for chrom. $key1 the start coord is $sorted_coords[0] and the last coord is $last\n";
			for (my $i = $sorted_coords[0]; $i <= $last - 1; $i++){
				my $t = $i + 1;
				if ($coverage{$key1}{$i} == $coverage{$key1}{$t}){
				#	print "coverage for $key1 at position $i equals coverage at $t and equals $coverage{$key1}{$i}\n";
				}
				else {
					my $cov = $coverage{$key1}{$t};
			#		print "This coverage ($cov) is being added to consolidate\n";
					$consolidate{$key1}{$t} = $cov;
				}
			}
		@sorted_coords = ();
	}
	if($file =~ /fold/){
#		if ($file =~ /plus/){
#			print "track type=bedGraph yLineOnOff=on yLineMark=2\n";
#		}
#		elsif($file =~ /minus/){
#			print "track type=bedGraph yLineOnOff=on yLineMark=-2\n";
#		}
#		
	}
	else{
		if(defined $opts{p}){
			$strand = "+";
			$color = "204,0,0";
			print "type=bedGraph color=204,0,0 autoScale=on\n";
		}
		elsif(defined $opts{m}){
			$strand = "-";
			$color = "0,0,175";
			print "type=bedGraph color=0,0,175 autoScale=on\n";
		}
	}
	
	foreach my $key1 (sort {$a cmp $b} keys %consolidate){
		my @sorted_coords = sort {$a <=> $b} keys %{$consolidate{$key1}};
		my $last = pop(@sorted_coords);
		my $z = scalar(@sorted_coords);
		my $stop = $z - 1;
	#	print "in consolidate, for chrom $key1 the start is $sorted_coords[0] and the stop is $last\n";
		for (my $i = 0; $i < $stop; $i++){
			my $t = $i + 1;	
			my $start = $sorted_coords[$i] - 1;
			my $stop = $sorted_coords[$t] - 1;
			if(defined($opts{B})){
				if($consolidate{$key1}{$sorted_coords[$i]} != 0){
					print "$key1\t$start\t$stop\tntcov2BED\t$consolidate{$key1}{$sorted_coords[$i]}\t$strand\t$start\t$stop\t$color\n";
				}
			}
			else{
				print "$key1\t$start\t$stop\t$consolidate{$key1}{$sorted_coords[$i]}\n";
			}
		}
		@sorted_coords = ();
	}
}

elsif(defined $opts{R}){
	my(%ntcov, %ntcov2);
	print STDERR "Reverse option selected, converting bedgraph to ntcov.txt\n";
	open(GENOME, "< $opts{S}") || die "Cannot open $opts{S}";
	while(my $line = <GENOME>){
		chomp($line);
		my @tabs = split("\t", $line);
		for(my $i = 1; $i <= $tabs[1]; $i++){
			$ntcov{$tabs[0]}{$i} = 0;
			$ntcov2{$tabs[0]}++;
		}
	}
	open(GRAPH, "< $file") || die "cannot open bedgraph file $file"; 
	while(my $line = <GRAPH>){
		chomp($line);
		if($line =~ /^#/){
		}
		else{
			my @tabs = split("\t", $line);
			$tabs[1] = $tabs[1] + 1;
			for(my $i = $tabs[1]; $i <= $tabs[2]; $i++){
				$ntcov{$tabs[0]}{$i} = $tabs[3];
				#print "$tabs[0]}\t$i\t$tabs[3]\n";
			}
		}
	}
	foreach my $chr (sort {$a cmp $b} keys %ntcov2){
		foreach my $nt (sort {$a <=> $b} keys %{$ntcov{$chr}}){
			print "$chr\t$nt\t$ntcov{$chr}{$nt}\n";
		}
	}
}		
