#! /usr/bin/perl

### this script will parse the compiles.TERM-ProSite.mergeBed files generated by getFinalProcessingSites.sh located
### in Multiomics/TSS-seq/Sub_files/
### output files are automatically generated

use Cwd;
use Getopt::Std;
getopts("i:S:", \%opts);

if(not defined($opts{i})){
	die "Must provide an input file!

********
Usage: ntcov2foldchange.pl <options> -i <in.mergeBed>
********

where options are:
	-S <str> provide a path and prefix string for output files\n\n";
}

my($path, @inconsist, %Pro, %TERM, %inconsistTERM);
if(defined($opts{S})){
	$path = $opts{S};
}
else{
	$path = getcwd;
	$path = $path . "/";
}

open(BED, "> $path" . "finalProSites.bed") || die "Cannot open $path" . "finalProSites.bed!\n";
my $testCount = 0;

open(FILE, "< $opts{i}") || die "Cannot open file $opts{i}!\n\n";
while(my $line =<FILE>){
	chomp($line);
	my @tabs = split("\t", $line);
	my @names = split(",", $tabs[3]);
	if($tabs[4] =~ /-/){
		if($names[0] =~ /^TERM/){
			push(@inconsist, $line);
			foreach my $N (@names){
				if($N =~ /TERM/){
					$inconsistTERM{$N}++;
				}
			}
		}
		elsif($names[$tabs[5] - 1] =~ /^Pro/){
			push(@inconsist, $line);
			foreach my $N (@names){
				if($N =~ /TERM/){
					$inconsistTERM{$N}++;
				}
			}
		}
		elsif($tabs[2] - $tabs[1] != $tabs[5]){
			push(@inconsist, $line);
			foreach my $N (@names){
				if($N =~ /TERM/){
					$inconsistTERM{$N}++;
				}
			}
		}
		else{
			if(scalar(@names) == 2){
				my $bedLine = join("\t", $tabs[0], $tabs[1], $tabs[2], "ProSite", "0", $tabs[4]);
				print BED "$bedLine\n";
				#push(@bed, $bedLine);
				foreach my $N (@names){
					if($N =~ /TERM/){
						$TERM{$N}++;
					}
				}
			}		
			else{
				my(%temp);
				foreach	my $N (@names){
					$N =~ /(\S+)_\d+/;
					$temp{$1}++;
				}
				if($temp{"Pro"} == 1){
					my $bedLine = join("\t", $tabs[0], $tabs[1], $tabs[2], "ProSite", "1", $tabs[4]);
					print BED "$bedLine\n";
					#push(@bed, $bedLine);
					foreach my $N (@names){
						if($N =~ /Pro/){
							#push(@Pro, $N);
							$Pro{$N}++;
						}
						elsif($N =~ /TERM/){
							#push(@TERM, $N);
							$TERM{$N}++;
						}
					}
				}
				elsif($temp{"Pro"} > 1){
					#print BED "test hit!\n";
					my $c = 0;
					my $z = 0;
					my @tempNames = @names;
					while(shift(@tempNames) =~ /Pro/){
						$c++;
					}
					#print BED "c = $c\n";
					while(shift(@tempNames) =~ /TERM/){
						$z++;
					}
					$z++;
					#print BED "z = $z\n";
					my $stop = $tabs[1] + $c + $z;
					my $bedLine = join("\t", $tabs[0], $tabs[1], $stop, "ProSite", $c - 1, $tabs[4]);
					print BED "$bedLine\n";
					if(($c + $z) < $tabs[5]){
						#print BED "Not done with line!\tc = $c\n";
						$tabs[1] = $stop;
						until($z + $c == $tabs[5]){
							my $c2 = 1;
							my $z2 = 1;
							$c++;
							while(shift(@tempNames) =~ /Pro/){
								$c++;
								$c2++;
							}
							#print BED "c = $c, c2 = $c2\n";
							$z++;
							while(shift(@tempNames) =~ /TERM/){
								$z++;
								$z2++;
							}
							my $stop = $tabs[1] + $c2 + $z2;
							my $bedLine = join("\t", $tabs[0], $tabs[1], $stop, "ProSite", $c2 - 1, $tabs[4]);
							print BED "$bedLine\n";
							#print BED "c = $c, z = $z\n";
						}
					}
					foreach my $N (@names){
						if($N =~ /Pro/){
							#push(@Pro, $N);
							$Pro{$N}++;
						}
						elsif($N =~ /TERM/){
							#push(@TERM, $N);
							$TERM{$N}++;
						}
					}
				}
			}
		}
	}
	if($tabs[4] !~ /-/){
		if($names[0] =~ /^Pro/){
			push(@inconsist, $line);
			foreach my $N (@names){
				if($N =~ /TERM/){
					$inconsistTERM{$N}++;
				}
			}
		}
		elsif($names[$tabs[5] - 1] =~ /^TERM/){
			push(@inconsist, $line);
			foreach my $N (@names){
				if($N =~ /TERM/){
					$inconsistTERM{$N}++;
				}
			}
		}
		elsif($tabs[2] - $tabs[1] != $tabs[5]){
			push(@inconsist, $line);
			foreach my $N (@names){
				if($N =~ /TERM/){
					$inconsistTERM{$N}++;
				}
			}
		}
		else{
			if(scalar(@names) == 2){
				my $bedLine = join("\t", $tabs[0], $tabs[1], $tabs[2], "ProSite", "0", $tabs[4]);
				print BED "$bedLine\n";
				#push(@bed, $bedLine);
				foreach my $N (@names){
					if($N =~ /Pro/){
						#push(@Pro, $N);
						$Pro{$N}++;
					}
					elsif($N =~ /TERM/){
						#push(@TERM, $N);
						$TERM{$N}++;
					}
				}
			}
			else{
				my(%temp);
				foreach	my $N (@names){
					$N =~ /(\S+)_\d+/;
					$temp{$1}++;
				}
				if($temp{"TERM"} == 1){
					my $bedLine = join("\t", $tabs[0], $tabs[1], $tabs[2], "ProSite", "0", $tabs[4]);
					print BED "$bedLine\n";
					foreach my $N (@names){
						if($N =~ /Pro/){
							#push(@Pro, $N);
							$Pro{$N}++;
						}
						elsif($N =~ /TERM/){
							#push(@TERM, $N);
							$TERM{$N}++;
						}
					}
				}
				elsif($temp{"TERM"} > 1){
					#print BED "test hit!\n";
					my $c = 0;
					my $z = 0;
					my @tempNames = @names;
					while(shift(@tempNames) =~ /TERM/){
						$c++;
					}
					#print BED "c = $c\n";
					while(shift(@tempNames) =~ /Pro/){
						$z++;
					}
					$z++;
					#print BED "z = $z\n";
					my $stop = $tabs[1] + $c + $z;
					my $bedLine = join("\t", $tabs[0], $tabs[1], $stop, "ProSite", $c - 1, $tabs[4]);
					print BED "$bedLine\n";
					if(($c + $z) < $tabs[5]){
						#print BED "Not done with line!\tc = $c\n";
						$tabs[1] = $stop;
						until($z + $c == $tabs[5]){
							my $c2 = 1;
							my $z2 = 1;
							$c++;
							while(shift(@tempNames) =~ /TERM/){
								$c++;
								$c2++;
							}
							#print BED "c = $c, c2 = $c2\n";
							$z++;
							while(shift(@tempNames) =~ /Pro/){
								$z++;
								$z2++;
							}
							my $stop = $tabs[1] + $c2 + $z2;
							my $bedLine = join("\t", $tabs[0], $tabs[1], $stop, "ProSite", $c2 - 1, $tabs[4]);
							print BED "$bedLine\n";
							#print BED "c = $c, z = $z\n";
						}
					}
					foreach my $N (@names){
						if($N =~ /Pro/){
							#push(@Pro, $N);
						$Pro{$N}++;
						}
						elsif($N =~ /TERM/){
							#push(@TERM, $N);
							$TERM{$N}++;
						}
					}
				}
			}
		}
	}
}
				
open(OUT1, "> $path" . "ProSites.txt") || die "Cannot open $path" . "ProSites.txt!\n";
#open(OUT2, "> $path" . "TERMSites.txt") || die "Cannot open $path" . "TERMSites.txt!\n";
open(OUT3, "> $path" . "InconsistentTERMSites.txt") || die "Cannot open $path" . "InconsistentTERMSites.txt!\n";

#foreach my $P (keys %Pro){
#	print OUT1 "$P\n";
#}

foreach my $T (keys %TERM){
	print OUT1 "$T\n";
}

foreach my $T (keys %inconsistTERM){
	print OUT3 "$T\n";
}

#foreach my $P (@Pro){
#	print OUT1 "$P\n";
#}

#foreach my $T (@TERM){
#	print OUT2 "$T\n";
#}

#foreach my $line (@bed){
#	print BED "$line\n";
#}

my $count = scalar(@inconsist);
print STDERR "There are $count inconsistent lines in the input file\n";
print STDERR "There are $testCount lines that have not been processed\n";

#foreach my $line (@inconsist){
#	print OUT3 "$line\n";
#}
